//Protobuf_File_Loader.cc - A part of DICOMautomaton 2016. Written by hal clark.
//
// This program loads data from files which have been serialized in Protobuf format.
//

#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <string>    
#include <vector>
#include <set> 
#include <map>
#include <unordered_map>
#include <list>
#include <functional>
#include <thread>
#include <array>
#include <mutex>
#include <limits>
#include <cmath>

#include <cstdlib>            //Needed for exit() calls.
#include <utility>            //Needed for std::pair.
#include <algorithm>
#include <experimental/optional>

#include <boost/algorithm/string.hpp> //For boost:iequals().

#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>

#include <pqxx/pqxx>          //PostgreSQL C++ interface.

#include "YgorMisc.h"         //Needed for FUNCINFO, FUNCWARN, FUNCERR macros.
#include "YgorMath.h"         //Needed for vec3 class.
#include "YgorMathPlottingGnuplot.h" //Needed for YgorMathPlottingGnuplot::*.
#include "YgorMathChebyshev.h" //Needed for cheby_approx class.
#include "YgorStats.h"        //Needed for Stats:: namespace.
#include "YgorFilesDirs.h"    //Needed for Does_File_Exist_And_Can_Be_Read(...), etc..
#include "YgorContainers.h"   //Needed for bimap class.
#include "YgorPerformance.h"  //Needed for YgorPerformance_dt_from_last().
#include "YgorAlgorithms.h"   //Needed for For_Each_In_Parallel<..>(...)
#include "YgorArguments.h"    //Needed for ArgumentHandler class.
#include "YgorString.h"       //Needed for GetFirstRegex(...)
#include "YgorImages.h"
#include "YgorImagesIO.h"
#include "YgorImagesPlotting.h"

#include "Explicator.h"       //Needed for Explicator class.
#include "YgorDICOMTools.h"   //Needed for Is_File_A_DICOM_File(...);

#include "Structs.h"
#include "Structs_IO_Protobufs.h"

#include "Imebra_Shim.h"      //Wrapper for Imebra library. Black-boxed to speed up compilation.

#include "Serialization.pb.h" //Is generated by the protocol buffer compiler. 


bool Load_From_Protobuf_Files( Drover &DICOM_data,
                               std::map<std::string,std::string> & /* InvocationMetadata */,
                               std::string &FilenameLex,
                               std::list<boost::filesystem::path> &Filenames ){

/*
    ////////////////////////////////////
    {
        Vec3DoubleMsg   vec3msg; //For testing.

        //Write a sample protobuf file for testing.
        vec3msg.set_x(1.0);
        vec3msg.set_y(2.0);
        vec3msg.set_z(3.0);
        std::fstream fo("/tmp/test_pb.proto", std::ios::out | std::ios::trunc | std::ios::binary);
        if(!vec3msg.SerializeToOstream(&fo)){
            FUNCERR("Could not write dummy test protobuf to /tmp/");
        }
        fo.close();
    }
    ////////////////////////////////////
*/

    //Cycle through the known, acceptable types trying to parse until one works.
    std::list<boost::filesystem::path> Filenames_Copy(Filenames);
    Filenames.clear();
    for(const auto &fn : Filenames_Copy){
        std::ifstream fi(fn.string(), std::ios::binary);
        if(!fi) continue;

        //Because protobufs with zero length are technically considered valid, but we won't accept them because such
        // messages are totally useless here, explicitly check for zero-length files.
        {
            fi.seekg(0,fi.end);
            const auto length = fi.tellg();
            if(length == 0){
                Filenames.emplace_back(fn);
                continue;
            }
            fi.seekg(0,fi.beg);
        }
            
/*
        //////////////////////////// FOR TESTING ///////////////////////////
        { //Try a Vec3DoubleMsg.
            fi.seekg(0);
            Vec3DoubleMsg vec3msg;
            if(vec3msg.ParseFromIstream(&fi)){

                ////////////////////////////////////
                FUNCINFO("Was a valid vec3msg");

                vec3<double> avec;
                avec.x = 100.0;
                avec.y = 200.0;
                avec.z = 300.0;
                bool dummy;
                if(!from_protobuf(avec,vec3msg)) FUNCERR("Conversion A failed");
                if(!to_protobuf(avec,vec3msg)) FUNCERR("Conversion B failed");

                FUNCERR("OK: vec3 loaded as: " << avec);
                ////////////////////////////////////


                Filenames.emplace_back(fn);
                continue;

            }
        }
        //////////////////////////// FOR TESTING ///////////////////////////
*/

        //Drover class.
        {
            fi.seekg(0);
            DroverMsg drovermsg;
            if(fi && drovermsg.ParseFromIstream(&fi)){
                FUNCINFO("Was a valid drovermsg");
                
                Filenames.emplace_back(fn);
                continue;

            }
        }

        //Image_Array class.
        {
            fi.seekg(0);
            ImageArrayMsg imagearraymsg; 
            if(fi && imagearraymsg.ParseFromIstream(&fi)){
                FUNCINFO("Was a valid imagearraymsg");

                //...

                Filenames.emplace_back(fn);
                continue;

            }
        }

        //Dose_Array class.
        {
            fi.seekg(0);
            DoseArrayMsg dosearraymsg;
            if(fi && dosearraymsg.ParseFromIstream(&fi)){
                FUNCINFO("Was a valid dosearraymsg");

                //...

                Filenames.emplace_back(fn);
                continue;

            }
        }

        //Contour_Array class.
        {
            fi.seekg(0);
            ContourDataMsg contourdatamsg;
            if(fi && contourdatamsg.ParseFromIstream(&fi)){
                FUNCINFO("Was a valid contourdatamsg");

                //...

                Filenames.emplace_back(fn);
                continue;
            }
        }

        //Not a (known) protobuf file we can parse. Leave it as-is.
        Filenames.emplace_back(fn);
        continue;
    }

    return true;
}
